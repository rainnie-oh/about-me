<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Portfolio Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Red Hat Display', 'Inter', sans-serif;
            background-color: #1e1e1e;
            color: #dadada;
            overflow: hidden;
        }
        
        #p5-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="p5-container"></div>

    <script>
        // Configuration constants
        const PANEL_W = 240;
        const GRAPH_OFFSET_X = 80;
        const ROLE_RADIUS = 200;
        const MINDSET_OUTER_R = ROLE_RADIUS + 120;
        const TARGET_SPRING = 0.006;
        const DAMPING = 0.92;
        const MAX_V = 2.8;
        const MINDSET_REVEAL_MS = 1200;
        const MINDSET_DRIFT_AMP = 1.5;
        const MINDSET_DRIFT_SPEED = 0.12;
        const FADE_MS = 70;
        const ALPHA_LERP_RATE = 0.45;

        // Color palette
        const palette = {
            bg: "#1e1e1e",
            node: "#999999",
            nodeMuted: "rgba(153,153,153,0.25)",
            mindsetNode: "#666666",
            label: "#dadada",
            edge: "rgba(170,170,170,0.35)",
            edgeMuted: "rgba(170,170,170,0.12)",
            panelBg: "rgba(42,42,42,0.85)",
            panelText: "#bababa",
            accent: "#8B6CEF"
        };

        // Convert hex to RGB
        function hexToRgb(hex) {
            if (!hex) return { r: 0, g: 0, b: 0 };
            const h = hex.replace("#", "");
            const bigint = parseInt(h, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        }

        const ACCENT_RGB = hexToRgb(palette.accent);
        const NODE_RGB = hexToRgb(palette.node);

        // Application state
        let NODES = [];
        let LINKS = [];
        let NODE_BY_ID = {};
        let ROLE_TO_MINDSETS = {};
        let hovered = null;
        let listHoverId = null;
        let active = null;
        let expandedRoleId = null;
        let grabbed = null;
        let panel, treeBox, detailBox;
        let ringAngle = 0;
        let lastPanelClickTime = 0;
        let glowX, glowY;
        let glowSize = 120;
        let glowOpacity = 0.6;

        // Content data
        const DATA = {
            roles: {
                "UX/UI Designer": ["Empathy", "Creativity", "Data-driven", "Storytelling", "Quick prototype", "Collaboration"],
                "Baker": ["Patience", "Creativity", "Iteration", "Complexity"],
                "Musician": ["Aesthetics", "Storytelling", "Flow"],
                "Craftswoman": ["Playfulness", "Creativity", "Observation", "Vibe coding", "Prototype"]
            }
        };

        const ROLE_COPY = {
            "UX/UI Designer": "I explore and share new ways of working so that teams can co-create, gather perspectives, and design with insight at the core.",
            "Baker": "I once ran a 200-member home bakery. Back home, I became the pâtissière for my family, colleagues, and friends.",
            "Musician": "I play piano and drums, and sometimes whistle with perfect pitch.",
            "Craftswoman": "I capture fleeting sparks of inspiration through craft—where aesthetics and patience turn the invisible into form."
        };

        const NAME_COPY = "I believe design should make the complex simple, the simple profound, and the profound approachable.";

        // Node class representing each element in the visualization
        class Node {
            constructor(id, label, type, x, y, parentId = null, roleAngle = null) {
                this.id = id;
                this.label = label;
                this.type = type;
                this.parentId = parentId;
                this.roleAngle = roleAngle;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.fx = 0;
                this.fy = 0;
                this.fixed = false;
                this.r = (type === "center") ? 8 : (type === "role" ? 7 : 5);
                this.tx = x;
                this.ty = y;
                this.floatPhase = random(TWO_PI);
                this.floatAmp = random(0.8, MINDSET_DRIFT_AMP);
                this.floatSpeed = random(0.12, MINDSET_DRIFT_SPEED);
                this.revealUntil = 0;
                this.alpha = 255;
                this.targetAlpha = 255;
                this._revealDone = true; // Track dandelion reveal state
            }

            // Check if point is inside node bounds
            isPointInside(mx, my) {
                const pos = this.renderPos();
                const dx = (mx - pos.x) || 0;
                const dy = (my - pos.y) || 0;
                return dx * dx + dy * dy <= (this.r + 6) * (this.r + 6);
            }

            // Calculate rendered position with drift and reveal animations
            renderPos() {
                let rx = this.x, ry = this.y;
                const t = millis() / 1000;

                // Apply float drift only if reveal is done
                if (this.type === "mindset" && this._revealDone) {
                    const phase = t * this.floatSpeed + this.floatPhase;
                    const easeOutFactor = 1 - Math.pow(sin(phase), 2);
                    rx += this.floatAmp * sin(phase) * easeOutFactor;
                    ry += this.floatAmp * cos(phase) * easeOutFactor;
                }

                // Handle reveal animation
                if (millis() < this.revealUntil) {
                    const rem = this.revealUntil - millis();
                    const p = constrain(1 - rem / MINDSET_REVEAL_MS, 0, 1);
                    rx = lerp(this.x, this.tx, this.easeOutCubic(p));
                    ry = lerp(this.y, this.ty, this.easeOutCubic(p));
                } else if (!this._revealDone && this.revealUntil > 0) {
                    this.x = this.tx;
                    this.y = this.ty;
                    this._revealDone = true;
                    this.floatAmp = 0;
                    this.revealUntil = 0;
                }

                return { x: rx, y: ry };
            }

            // Easing function
            easeOutCubic(t) {
                return 1 - pow(1 - t, 3);
            }

            // Draw the node
            drawNode() {
                if (this.alpha < 8) return;

                const pos = this.renderPos();
                const hl = (hovered === this) || (listHoverId === this.id) || (active && active.id === this.id);

                // Add soft white glow effect on hover
                if ((hovered === this || listHoverId === this.id) && (this.type === "role" || this.type === "center")) {
                    drawingContext.shadowBlur = 15;
                    drawingContext.shadowColor = "rgba(255, 255, 255, 0.3)";
                } else {
                    drawingContext.shadowBlur = 0;
                }

                // Set fill color based on node type and state
                if (hl) {
                    fill(ACCENT_RGB.r, ACCENT_RGB.g, ACCENT_RGB.b, this.alpha);
                } else {
                    if (this.type === "mindset") {
                        const rgb = hexToRgb(palette.mindsetNode);
                        fill(rgb.r, rgb.g, rgb.b, this.alpha);
                    } else {
                        fill(NODE_RGB.r, NODE_RGB.g, NODE_RGB.b, this.alpha);
                    }
                }

                noStroke();
                circle(pos.x, pos.y, this.r * 2);
                drawingContext.shadowBlur = 0; // Reset shadow
            }

            // Draw node label
            drawLabel() {
                if (this.alpha < 8) return;

                // Determine label visibility based on expansion state
                if (expandedRoleId) {
                    if (this.type === "mindset" && this.parentId !== expandedRoleId) return;
                    if (this.type === "role" && this.id !== expandedRoleId) return;
                    if (this.type === "center") return;
                } else {
                    if (this.type === "mindset" && !(hovered === this || listHoverId === this.id)) return;
                }

                const pos = this.renderPos();
                let col = palette.label;
                if (hovered === this || listHoverId === this.id) col = palette.accent;
                const rgb = hexToRgb(col);

                noStroke();
                fill(rgb.r, rgb.g, rgb.b, this.alpha);
                textFont("Red Hat Display, Inter, ui-sans-serif, system-ui");
                textSize(12);

                // Position label based on node type
                if (this.type === "role" || this.type === "center") {
                    if (this.label === "Baker" || this.label === "Musician" || this.type === "center") {
                        textAlign(LEFT, TOP);
                        text(this.label, pos.x + this.r + 6, pos.y + this.r + 6);
                    } else {
                        textAlign(LEFT, CENTER);
                        text(this.label, pos.x + this.r + 6, pos.y);
                    }
                } else {
                    textAlign(LEFT, CENTER);
                    text(this.label, pos.x + this.r + 6, pos.y);
                }
            }
        }

        // Link class representing connections between nodes
        class Link {
            constructor(a, b) {
                this.a = a;
                this.b = b;
                this.alpha = 255;
                this.targetAlpha = 255;
            }

            // Draw the link
            draw() {
                if (this.alpha < 6) return;
                const A = this.a.renderPos();
                const B = this.b.renderPos();
                stroke(170, 170, 170, this.alpha);
                strokeWeight(1.1);
                line(A.x, A.y, B.x, B.y);
            }
        }

        // Setup function - initializes the sketch
        function setup() {
            const canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('p5-container');
            
            glowX = width / 10;
            glowY = height / 10;
            textFont("Red Hat Display, Inter, ui-sans-serif, system-ui");
            
            buildLeftPanel();
            placeGraphNodes();
            rebuildTree();
            updateDetail(null);
        }

        // Position nodes in the graph
        function placeGraphNodes() {
            NODES = [];
            LINKS = [];
            NODE_BY_ID = {};
            ROLE_TO_MINDSETS = {};
            
            const cx = (width / 2) + GRAPH_OFFSET_X;
            const cy = height / 2;

            // Create center node
            const center = addNode(new Node("me", "Rainnie", "center", cx, cy));

            // Define role positions and create nodes
            const roleOrder = ["UX/UI Designer", "Baker", "Musician", "Craftswoman"];
            
            for (let i = 0; i < roleOrder.length; i++) {
                const role = roleOrder[i];
                let angle;
                
                // Set fixed angles for each role
                if (role === "UX/UI Designer") angle = -HALF_PI;
                else if (role === "Baker") angle = PI;
                else if (role === "Musician") angle = 0;
                else if (role === "Craftswoman") angle = HALF_PI;
                
                const tx = cx + ROLE_RADIUS * cos(angle);
                const ty = cy + ROLE_RADIUS * sin(angle);
                const roleNode = addNode(new Node("role_" + i, role, "role", cx + random(-6, 6), cy + random(-6, 6), null, angle));
                
                roleNode.tx = tx;
                roleNode.ty = ty;
                LINKS.push(new Link(center, roleNode));

                // Create mindset nodes for this role
                const items = DATA.roles[role];
                const baseOpp = angle + PI;
                const wedgeDeg = 100;
                let angles = [];
                
                if (items.length === 1) {
                    angles = [baseOpp];
                } else {
                    const step = radians(wedgeDeg) / (items.length - 1);
                    const start = baseOpp - radians(wedgeDeg) / 2;
                    for (let j = 0; j < items.length; j++) angles.push(start + j * step);
                }

                ROLE_TO_MINDSETS[roleNode.id] = [];
                
                for (let j = 0; j < items.length; j++) {
                    const mLabel = items[j];
                    const useInner = (random() < 0.5);
                    const radial = useInner ? ROLE_RADIUS * 0.5 : MINDSET_OUTER_R * 1.1;
                    const mx = cx + radial * cos(angles[j]);
                    const my = cy + radial * sin(angles[j]);
                    const mid = roleNode.id + "_m" + j;
                    
                    const mNode = addNode(new Node(mid, mLabel, "mindset", cx + random(-6, 6), cy + random(-6, 6), roleNode.id, angles[j]));
                    
                    const constrained = constrainToBounds(mx, my);
                    mNode.tx = constrained.x;
                    mNode.ty = constrained.y;
                    
                    mNode.revealUntil = 0;
                    mNode._revealDone = true;
                    
                    LINKS.push(new Link(roleNode, mNode));
                    ROLE_TO_MINDSETS[roleNode.id].push(mNode.id);
                }
            }

            updateAlphasImmediate();
        }

        // Constrain coordinates to visible area
        function constrainToBounds(x, y) {
            const margin = 36;
            const minX = PANEL_W + margin;
            const maxX = width - margin;
            const minY = margin;
            const maxY = height - margin;
            return { x: constrain(x, minX, maxX), y: constrain(y, minY, maxY) };
        }

        // Add node to collections
        function addNode(n) {
            NODES.push(n);
            NODE_BY_ID[n.id] = n;
            return n;
        }

        // Build the left panel UI
        function buildLeftPanel() {
            if (panel) panel.remove();
            
            panel = createDiv();
            panel.position(20, 20);
            panel.style("width", PANEL_W + "px");
            panel.style("background", "rgba(42,42,42,0.7)");
            panel.style("backdrop-filter", "blur(10px)");
            panel.style("border-radius", "12px");
            panel.style("padding", "12px");
            panel.style("color", palette.panelText);
            panel.style("font-family", "Red Hat Display, Inter, sans-serif");
            panel.style("user-select", "none");
            panel.style("box-sizing", "border-box");

            const header = createElement("div", "About me");
            header.parent(panel);
            header.style("color", palette.accent);
            header.style("font-weight", "600");
            header.style("margin-bottom", "8px");

            treeBox = createDiv().parent(panel);
            treeBox.style("margin-bottom", "10px");

            detailBox = createDiv().parent(panel);
            detailBox.style("background", "rgba(255,255,255,0.02)");
            detailBox.style("padding", "12px");
            detailBox.style("border-radius", "8px");
        }

        let TREE_ELEMS = {};

        // Rebuild the tree view
        function rebuildTree() {
            treeBox.html("");
            TREE_ELEMS = {};

            addTreeItem("me", "Rainnie", 0, true);
            
            const roleOrder = ["UX/UI Designer", "Baker", "Musician", "Craftswoman"];
            
            for (let i = 0; i < roleOrder.length; i++) {
                const role = roleOrder[i];
                addTreeItem("role_" + i, role, 1, true);
                
                const group = createDiv().parent(treeBox);
                group.id("group_role_" + i);
                group.style("display", "none");
                group.style("margin-left", "32px");
                group.style("position", "relative");
                
                const mids = ROLE_TO_MINDSETS["role_" + i] || [];
                
                mids.forEach((mid, index) => {
                    if (index < 3) {
                        const n = NODE_BY_ID[mid];
                        const item = createDiv(n.label).parent(group);
                        item.style("padding", "4px 6px");
                        item.style("font-size", "13px");
                        item.style("color", "rgba(255,255,255,0.55)");
                        item.style("position", "relative");
                        
                        item.mouseOver(() => { listHoverId = mid; refreshTreeStyles(); });
                        item.mouseOut(() => { if (listHoverId === mid) listHoverId = null; refreshTreeStyles(); });
                    }
                });
            }
            
            refreshTreeStyles();
        }

        // Add item to tree view
        function addTreeItem(id, text, level = 0, clickable = true) {
            const row = createDiv(text).parent(treeBox);
            row.style("padding", "6px 8px 6px 24px");
            row.style("margin-left", (level * 16) + "px");
            row.style("cursor", clickable ? "pointer" : "default");
            row.style("border-radius", "6px");
            row.style("position", "relative");
            
            if (level > 0) {
                // Vertical line
                const vLine = createDiv("");
                vLine.parent(row);
                vLine.style("position", "absolute");
                vLine.style("left", (level * 16 - 12) + "px");
                vLine.style("top", "0");
                vLine.style("width", "1px");
                vLine.style("height", "100%");
                vLine.style("background", "rgba(255,255,255,0.12)");
                
                // Horizontal line
                const hLine = createDiv("");
                hLine.parent(row);
                hLine.style("position", "absolute");
                hLine.style("left", (level * 16 - 12) + "px");
                hLine.style("top", "50%");
                hLine.style("width", "16px");
                hLine.style("height", "1px");
                hLine.style("background", "rgba(255,255,255,0.12)");
            }

            row.mouseOver(() => { listHoverId = id; refreshTreeStyles(); });
            row.mouseOut(() => { if (listHoverId === id) listHoverId = null; refreshTreeStyles(); });

            if (clickable) {
                row.mousePressed(() => {
                    lastPanelClickTime = millis();
                    const node = NODE_BY_ID[id];
                    if (!node) return;
                    setActiveNode(node);
                });
            }
            
            TREE_ELEMS[id] = row;
            return row;
        }

        // Refresh tree view styles
        function refreshTreeStyles() {
            Object.keys(ROLE_TO_MINDSETS).forEach(roleId => {
                const idx = roleId.split("_")[1];
                const g = select("#group_role_" + idx);
                if (g) g.style("display", expandedRoleId === roleId ? "block" : "none");
            });

            Object.keys(TREE_ELEMS).forEach(id => {
                const el = TREE_ELEMS[id];
                const isActive = active && active.id === id;
                const isHover = listHoverId === id;
                el.style("background", isActive ? "rgba(139,108,239,0.12)" : (isHover ? "rgba(255,255,255,0.04)" : "transparent"));
                el.style("color", isActive ? palette.accent : palette.panelText);
            });
        }

        // Set the active node
        function setActiveNode(node) {
            if (!node) return;
            
            active = node;
            
            if (node.type === "center") {
                expandedRoleId = null;
                updateDetail(node);
            } else if (node.type === "role") {
                setExpandedRole(node.id);
                updateDetail(node);
            } else if (node.type === "mindset") {
                updateDetail(null);
            }
            
            refreshTreeStyles();
            updateAlphasImmediate();
        }

        // Update detail panel content
        function updateDetail(node) {
            detailBox.html("");
            
            if (!node) {
                const p = createDiv("Click a role to view details.");
                p.parent(detailBox);
                p.style("color", palette.panelText);
                return;
            }
            
            const body = createDiv().parent(detailBox);
            body.style("color", palette.panelText);
            body.style("font-size", "13px");
            body.style("line-height", "1.5");
            
            if (node.type === "center") {
                body.html(NAME_COPY);
            } else if (node.type === "role") {
                body.html(ROLE_COPY[node.label] || "");
                
                // For Webflow, you'll need to replace these with your actual image URLs
                const imageRow = createDiv().parent(detailBox);
                imageRow.style("display", "flex");
                imageRow.style("gap", "14px");
                imageRow.style("margin-top", "14px");
                
                // Image containers would go here
                // createImageContainer(`images/${node.label}-1.jpg`);
                // createImageContainer(`images/${node.label}-2.jpg`);
            }
        }

        // Set expanded role with dandelion reveal effect
        function setExpandedRole(roleId) {
            expandedRoleId = roleId;
            updateAlphasImmediate();

            const now = millis();
            (ROLE_TO_MINDSETS[roleId] || []).forEach(mid => {
                const m = NODE_BY_ID[mid];

                // Calculate starting offset for dandelion effect
                const maxAngleOffset = PI / 2;
                const delta = random(-maxAngleOffset, maxAngleOffset);
                const startAngle = (m.roleAngle || 0) + delta;
                const startRadius = random(40, 120);
                const startX = m.tx + cos(startAngle) * startRadius;
                const startY = m.ty + sin(startAngle) * startRadius;

                m.x = startX;
                m.y = startY;

                const dur = random(1000, 1500);
                m.revealUntil = now + dur;
                m._revealDone = false;
                m.floatAmp = 0;
            });
            
            refreshTreeStyles();
        }

        // Mouse interaction handlers
        function mousePressed() {
            grabbed = getNodeUnderMouse();
            if (grabbed) {
                grabbed.fixed = true;
                grabbed.vx = 0;
                grabbed.vy = 0;
            }
        }

        function mouseDragged() {
            if (grabbed) {
                const dx = mouseX - grabbed.x;
                const dy = mouseY - grabbed.y;
                
                grabbed.x = constrain(mouseX, PANEL_W + 20, width - 20);
                grabbed.y = constrain(mouseY, 20, height - 20);
                
                if (grabbed.type === "role" && active && active.id === grabbed.id) {
                    const mids = ROLE_TO_MINDSETS[grabbed.id] || [];
                    mids.forEach(mid => {
                        const m = NODE_BY_ID[mid];
                        if (m) {
                            m.x = constrain(m.x + dx, PANEL_W + 20, width - 20);
                            m.y = constrain(m.y + dy, 20, height - 20);
                        }
                    });
                }
            }
        }

        function mouseReleased() {
            if (grabbed) {
                grabbed.fixed = false;
                grabbed = null;
            }
        }

        function mouseClicked() {
            if (millis() - lastPanelClickTime < 300) return;

            const n = getNodeUnderMouse();
            if (!n) {
                active = null;
                expandedRoleId = null;
                updateDetail(null);
                refreshTreeStyles();
                updateAlphasImmediate();
                return;
            }
            
            setActiveNode(n);
        }

        // Get node under mouse position
        function getNodeUnderMouse() {
            for (let i = NODES.length - 1; i >= 0; i--) {
                const n = NODES[i];
                if (!isNodeVisible(n)) continue;
                if (n.isPointInside(mouseX, mouseY)) return n;
            }
            return null;
        }

        // Check if node should be visible
        function isNodeVisible(n) {
            if (expandedRoleId) {
                if (n.type === "center") return (n.id === expandedRoleId);
                if (n.type === "role") return n.id === expandedRoleId;
                if (n.type === "mindset") return n.parentId === expandedRoleId;
                return false;
            } else {
                return n.type !== "mindset";
            }
        }

        // Main draw loop
        function draw() {
            background(palette.bg);
            
            // Draw glow effect
            drawingContext.save();
            drawingContext.filter = 'blur(50px)';
            noStroke();
            fill(ACCENT_RGB.r, ACCENT_RGB.g, ACCENT_RGB.b, glowOpacity * 255);
            circle(glowX, glowY, glowSize);
            drawingContext.restore();
            
            // Update glow position to follow mouse
            glowX = lerp(glowX, mouseX, 0.05);
            glowY = lerp(glowY, mouseY, 0.05);
            
            drawCoordinateSystem();
            simulate();
            updateAlphas();

            // Draw links
            for (const L of LINKS) L.draw();

            // Find hovered node
            hovered = null;
            for (const n of NODES) {
                if (!isNodeVisible(n)) continue;
                if (n.isPointInside(mouseX, mouseY)) {
                    hovered = n;
                    break;
                }
            }

            // Draw nodes
            for (const n of NODES) n.drawNode();
            for (const n of NODES) n.drawLabel();

            // Draw highlight ring if center is selected
            if (active && active.type === "center") {
                drawHighlightRing(active);
            }

            refreshTreeStyles();
        }

        // Immediately update alpha targets
        function updateAlphasImmediate() {
            NODES.forEach(n => {
                if (expandedRoleId) {
                    if (n.type === "role") {
                        n.targetAlpha = (n.id === expandedRoleId) ? 255 : 40;
                    } else if (n.type === "mindset") {
                        n.targetAlpha = (n.parentId === expandedRoleId) ? 255 : 40;
                    } else if (n.type === "center") {
                        n.targetAlpha = 40;
                    }
                } else {
                    n.targetAlpha = 255;
                }
            });

            LINKS.forEach(l => {
                if (expandedRoleId) {
                    const isRoleToMindsetLink = l.a.id === expandedRoleId || l.b.id === expandedRoleId;
                    l.targetAlpha = isRoleToMindsetLink ? 255 : 0;
                } else {
                    if ((l.a.type === "center" && l.b.type === "role") ||
                        (l.b.type === "center" && l.a.type === "role")) {
                        l.targetAlpha = 255;
                    } else {
                        l.targetAlpha = 0;
                    }
                }
            });
        }

        // Smoothly update alpha values
        function updateAlphas() {
            const factor = ALPHA_LERP_RATE;
            NODES.forEach(n => {
                n.alpha = lerp(n.alpha, n.targetAlpha, factor);
            });
            LINKS.forEach(l => {
                l.alpha = lerp(l.alpha, l.targetAlpha, factor);
            });
        }

        // Physics simulation
        function simulate() {
            // Reset forces
            for (const n of NODES) {
                n.fx = 0;
                n.fy = 0;
            }

            // Target spring force
            for (const n of NODES) {
                const dx = (n.tx || n.x) - n.x;
                const dy = (n.ty || n.y) - n.y;
                n.fx += dx * TARGET_SPRING;
                n.fy += dy * TARGET_SPRING;
            }

            // Soft repulsion between nodes
            const kr = 120;
            const minSep = 28;
            
            for (let i = 0; i < NODES.length; i++) {
                for (let j = i + 1; j < NODES.length; j++) {
                    const a = NODES[i], b = NODES[j];
                    if (!isNodePotentiallyVisible(a) && !isNodePotentiallyVisible(b)) continue;
                    
                    let dx = b.x - a.x, dy = b.y - a.y;
                    let d = Math.hypot(dx, dy);
                    d = Math.max(0.001, d);
                    
                    if (d < minSep * 2) {
                        const f = kr / (d * d);
                        const nx = dx / d, ny = dy / d;
                        a.fx -= f * nx;
                        a.fy -= f * ny;
                        b.fx += f * nx;
                        b.fy += f * ny;
                    }
                }
            }

            // Ensure mindsets stay at appropriate distance from center
            const center = NODE_BY_ID["me"];
            
            for (const roleId in ROLE_TO_MINDSETS) {
                const roleNode = NODE_BY_ID[roleId];
                const rc = dist(center.x, center.y, roleNode.tx, roleNode.ty);
                
                (ROLE_TO_MINDSETS[roleId] || []).forEach(mid => {
                    const m = NODE_BY_ID[mid];
                    const dm = dist(center.x, center.y, m.x, m.y);
                    const minR = rc * 0.72;
                    
                    if (dm < minR) {
                        m.fx += (m.tx - m.x) * 0.05;
                        m.fy += (m.ty - m.y) * 0.05;
                    }
                    
                    const constrained = constrainToBounds(m.tx, m.ty);
                    m.tx = constrained.x;
                    m.ty = constrained.y;
                });
            }

            // Integrate forces with damping
            for (const n of NODES) {
                if (n.fixed) continue;
                
                n.vx = (n.vx + n.fx) * DAMPING;
                n.vy = (n.vy + n.fy) * DAMPING;
                n.vx = constrain(n.vx, -MAX_V, MAX_V);
                n.vy = constrain(n.vy, -MAX_V, MAX_V);
                n.x += n.vx;
                n.y += n.vy;
            }
        }

        // Check if node might be visible soon
        function isNodePotentiallyVisible(n) {
            if (expandedRoleId) {
                if (n.type === "center") return true;
                if (n.type === "role") return n.id === expandedRoleId;
                if (n.type === "mindset") return n.parentId === expandedRoleId;
                return false;
            } else {
                return n.type !== "mindset";
            }
        }

        // Draw highlight ring around center
        function drawHighlightRing(center) {
            const roleNodes = Object.keys(ROLE_TO_MINDSETS).map(id => NODE_BY_ID[id]);
            if (roleNodes.length === 0) return;
            
            let sumR = 0;
            roleNodes.forEach(rn => sumR += dist(center.x, center.y, rn.tx, rn.ty));
            
            const ringR = sumR / roleNodes.length;
            ringAngle += 0.006;
            
            push();
            translate(center.x, center.y);
            rotate(ringAngle);
            noFill();
            stroke(ACCENT_RGB.r, ACCENT_RGB.g, ACCENT_RGB.b, 200);
            drawingContext.setLineDash([6, 6]);
            strokeWeight(1.2);
            ellipse(0, 0, ringR * 2, ringR * 2);
            
            // Draw dots at role angles
            const roleNames = Object.keys(DATA.roles);
            for (let i = 0; i < roleNames.length; i++) {
                const a = -HALF_PI + i * (TWO_PI / roleNames.length);
                const rx = ringR * cos(a);
                const ry = ringR * sin(a);
                noStroke();
                fill(ACCENT_RGB.r, ACCENT_RGB.g, ACCENT_RGB.b, 220);
                circle(rx, ry, 6);
            }
            
            drawingContext.setLineDash([]);
            pop();
        }

        // Draw coordinate system in the background
        function drawCoordinateSystem() {
            const cx = (width / 2) + GRAPH_OFFSET_X;
            const cy = height / 2;
            const padding = 48;
            
            // Draw axes with dashed lines
            stroke(170, 170, 170, 100);
            strokeWeight(1);
            drawingContext.setLineDash([5, 5]);
            
            line(padding, cy, width - padding, cy);
            line(cx, padding, cx, height - padding);
            
            drawingContext.setLineDash([]);
            
            // Add axis labels
            noStroke();
            fill(170, 170, 170, 100);
            textFont("Red Hat Display, Inter, ui-sans-serif, system-ui");
            textSize(12);
            
            textAlign(CENTER, TOP);
            text("Physical", padding + 30, cy + 16);
            text("Digital", width - padding - 30, cy + 16);
            
            textAlign(RIGHT, BOTTOM);
            text("Shared\nExperience", cx - 16, padding - 2);
            
            textAlign(RIGHT, TOP);
            text("Self\nExpression", cx - 16, height - padding + 2);
        }

        // Handle window resize
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            placeGraphNodes();
            rebuildTree();
            updateDetail(active ? active : null);
        }

        // Constrain value between min and max
        function constrain(v, a, b) {
            return Math.max(a, Math.min(b, v));
        }

        // Initialize alpha values
        updateAlphasImmediate();
        updateAlphas();
    </script>
</body>
</html>